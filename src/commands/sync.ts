import fs from 'fs-extra';
import { Command } from 'commander';
import * as htmlparser2 from 'htmlparser2';
import { getFilteredPlugins } from '@versoly/plugins';
import { VersolyClient } from 'versoly-js-client';

import { logger } from '../logger';
import { VersolyFile } from 'src/types';
import { getLocalSyncSettings } from 'src/config';
import { generateComponent, generatePage, getAutoGeneratedStr } from 'src/lib/generateFiles';
import { getRegistryFiles } from 'src/lib/registry';
import { generateCSSFor } from 'src/lib/generateCSS';

const isAutoGenerated = (content: string) => {
  // css and js require different comments
  return content.includes(`auto-generated by Versoly`);
};

const addAutoGeneratedStr = (content: string) => {
  return `${getAutoGeneratedStr()}\n\n${content}`;
};

export const replaceCDNUrls = (html: string) => {
  //  https://d1pnnwteuly8z3.cloudfront.net/images/dafc1e05-b0e8-4c6d-b375-4a62333bbd5a/db204aff-2783-412a-9f3d-8ff54d267d9f.png
  return html.replace(
    /https:\/\/d1pnnwteuly8z3\.cloudfront\.net\/images\/[a-z0-9-]+\/[a-z0-9-]+\.(png|jpg|jpeg|gif|svg|webp|avif)/g,
    (match) => {
      const urlObj = new URL(match);
      const pathname = urlObj.pathname.split('/').at(-1);
      return `/images/${pathname}`;
    },
  );
};

export const sync = new Command()
  .name('sync')
  .description('Sync your code base to Versoly')
  .option('-o, --overwrite', 'overwrite existing files.', false)
  .option('-c, --config-file <path>', 'specify path to config file.', 'versoly.config.mjs')
  .action(async (options) => {
    const config = await getLocalSyncSettings(options['configFile']);

    if (config === null) {
      logger.error('Could not find versoly.config.(mjs|ts) in the current directory.');
      return;
    }

    const { token, siteId, rootDir, srcDir, publicDir, pagesDir, componentsDir, pluginsDir, exclude } = config;

    const packageJSONPath = rootDir + '/package.json';
    if (!fs.existsSync(`${packageJSONPath}`)) {
      logger.error('Could not find package.json in the current directory.');
      return;
    }

    const packageJSON = fs.readFileSync(packageJSONPath, 'utf-8');
    const jsFileExtension = JSON.parse(packageJSON)?.type === 'module' ? 'mjs' : 'js';

    logger.start('Fetching data...');

    // http://localhost:8080
    const client = new VersolyClient({ token, url: process.env.VERSOLY_API_URL ?? 'https://api.versoly.com/v1' });

    const { data: site, error } = await client.sites.get({ path: { siteId } });

    if (error) {
      logger.error('Error fetching site data:', error.detail);
      return;
    }

    const { data: pages, error: pagesError } = await client.pages.list({ path: { siteId } });
    if (pagesError) {
      logger.error('Error fetching pages:', pagesError.detail);
      return;
    }

    const { data: components, error: componentsError } = await client.components.list({ path: { siteId } });
    if (componentsError) {
      logger.error('Error fetching components:', componentsError.detail);
      return;
    }

    const { data: publicFiles, error: publicFilesError } = await client.publicFiles.list({ path: { siteId } });
    if (publicFilesError) {
      logger.error('Error fetching public files:', publicFilesError.detail);
      return;
    }

    const { data: redirects, error: redirectsError } = await client.redirects.list({ path: { siteId } });
    if (redirectsError) {
      logger.error('Error fetching redirects:', redirectsError.detail);
      return;
    }

    logger.success('Site data fetched successfully!');

    let newFiles: VersolyFile[] = [];

    newFiles.push({
      type: 'file',
      path: srcDir + '/.versoly/settings',
      extension: 'json',
      content: {
        _internal: {
          lastUpdateCheck: new Date().toISOString(),
        },
      },
    });

    const registryFiles = await getRegistryFiles();

    registryFiles.forEach((file) =>
      newFiles.push({
        ...file,
        path: srcDir + '/' + file.path,
        content: addAutoGeneratedStr(file.content as string),
      }),
    );

    publicFiles.data.forEach((file) => {
      // to disable use excludes
      newFiles.push({
        type: 'file',
        path: publicDir + '/' + file.path,
        extension: '',
        content: file.content,
      });
    });

    let imageUrlsSet: Set<string> = new Set();
    const addCleanImageUrl = (url: string) => {
      const cleanUrl = url.replace(/^['"{]|['"}]$/g, '');
      imageUrlsSet.add(cleanUrl);
    };

    if (site.favicon) {
      addCleanImageUrl(site.favicon);
    }

    let siteMetaTags = site.metaTags.map((tag) => {
      if (tag.value === 'og:image' || tag.value === 'twitter:image') {
        addCleanImageUrl(tag.content);
        return {
          ...tag,
          content: replaceCDNUrls(tag.content),
        };
      }
      return tag;
    });

    const siteConfigForAstro = {
      favicon: replaceCDNUrls(site.favicon || ''),
      title: site.seo.title,
      description: site.seo.description,
      head: site.head,
      scripts: site.scripts,
      metaTags: siteMetaTags,
      integrations: site.integrations,
      lang: 'US-en', // site.lang

      redirects: redirects.data.reduce(
        (acc, curr) => {
          acc[curr.fromUrl] = {
            status: curr.redirectType,
            destination: curr.toUrl,
          };
          return acc;
        },
        {} as Record<string, { status: 301 | 302; destination: string }>,
      ),
    };

    newFiles.push({
      type: 'file',
      path: srcDir + '/config/site',
      extension: jsFileExtension,
      content: addAutoGeneratedStr(`
/**
 * @typedef SiteConfig
 * @type {object}
 * @property {string} title
 * @property {string} description
 * @property {string} head
 * @property {string} scripts
 * @property {import("../utils/metaTagsToString").MetaTags} metaTags
 * @property {array} integrations
 * @property {string} lang
 * @property {string} favicon
 * @property {Record<string, { status: 301 | 302; destination: string }>} redirects
 */

/** @type {SiteConfig} */
export const SITE_CONFIG = ${JSON.stringify(siteConfigForAstro, null, 2)};`),
    });

    newFiles.push({
      type: 'file',
      path: srcDir + '/styles/versoly',
      extension: 'css',
      content:
        `/* auto-generated by Versoly */
` + generateCSSFor['versoly-ui'](site.config as any),
    });

    function extractImageUrls(content: string) {
      const parser = new htmlparser2.Parser({
        onopentag(name, attributes) {
          if (name === 'img' && attributes.src) {
            addCleanImageUrl(attributes.src);
          }

          if (attributes.style) {
            const styleContent = attributes.style;
            const urlMatch = styleContent.match(/url\((['"]?)(.*?)\1\)/);
            if (urlMatch?.[2]) {
              addCleanImageUrl(urlMatch[2]);
            }
          }
        },
      });

      parser.write(content);
      parser.end();
    }

    for (const page of pages.data) {
      const generated = await generatePage(page, pagesDir);
      if (generated) {
        newFiles.push({
          ...generated,
          content: replaceCDNUrls(generated.content),
        });
        extractImageUrls(page.content);
      }

      page.metaTags.forEach((tag) => {
        if (tag.value === 'og:image' || tag.value === 'twitter:image') {
          addCleanImageUrl(tag.content);
        }
      });
    }

    for (const component of components.data) {
      const generated = await generateComponent(component, componentsDir);
      if (generated) {
        newFiles.push({
          ...generated,
          content: replaceCDNUrls(generated.content),
        });
        extractImageUrls(component.content);
      }
    }

    const activePlugins = Array.from(new Set(newFiles.map((f) => f.plugins || []).flat()));

    let pluginsList = getFilteredPlugins({ HTML: '', activePlugins });
    pluginsList.map((p) => {
      if (!p.js) {
        return;
      }

      newFiles.push({
        type: 'file',
        path: pluginsDir + '/' + p.name,
        extension: 'js',
        content: addAutoGeneratedStr(p.js),
      });
    });

    newFiles.map((f) => {
      console.log({ path: f.path, extension: f.extension });
    });

    let doFilesWithoutAutogeneratedComment = false;
    for (const file of newFiles) {
      const { path, extension } = file;

      let filePath = path;
      if (extension) {
        filePath = path + '.' + extension;
      }

      if (fs.existsSync(`${filePath}`)) {
        const oldContent = fs.readFileSync(`${filePath}`, 'utf-8');

        if (!isAutoGenerated(oldContent)) {
          logger.info(`File ${filePath} does not have auto-generated comment.`);
          doFilesWithoutAutogeneratedComment = true;
        }
      }
    }

    // if options.overwrite undefined
    let shouldOverwriteOldFiles = false;
    if (doFilesWithoutAutogeneratedComment) {
      let value = await logger.prompt('What should happen to files without auto-generated comment?', {
        type: 'select',
        options: [
          { label: 'Skip', value: 'Skip', hint: 'files without auto-generated comment' },
          { label: 'Overwrite', value: 'Overwrite' },
        ],
        initial: 'Skip',
      });

      shouldOverwriteOldFiles = value.value === 'Overwrite';
    }

    if (!fs.existsSync(srcDir + '/.versoly')) {
      fs.mkdirSync(srcDir + '/.versoly', { recursive: true });
    }

    for (const file of newFiles) {
      let { path, content, extension } = file;

      const canSkip = exclude?.some((excludePath) => {
        if (!excludePath.endsWith('/*')) {
          return path.endsWith(excludePath);
        }
        const baseExcludePath = excludePath.slice(0, -2);
        return path.replace(rootDir, '').startsWith(baseExcludePath);
      });

      let filePath = path;
      if (extension) {
        filePath = path + '.' + extension;
      }

      if (canSkip) {
        logger.info(`Skipping excluded file: ${filePath}`);
        continue;
      }

      let oldContent = '';

      if (fs.existsSync(`${filePath}`)) {
        oldContent = fs.readFileSync(`${filePath}`, 'utf-8') || '';
      }

      let shouldWriteFile = true;

      if (oldContent.includes('@versoly/sync-disable')) {
        shouldWriteFile = false;
      }

      if (!shouldOverwriteOldFiles && !isAutoGenerated(oldContent)) {
        shouldWriteFile = false;
      }

      if (!oldContent) {
        shouldWriteFile = true;
      }

      if (!shouldWriteFile) {
        continue;
      }

      if (typeof content === 'object') {
        content = JSON.stringify(content, null, 2);
      }

      // fs.writeFileSync(`${filePath}`, content);
    }

    await logger.info('Images found:', imageUrlsSet.size);

    Array.from(imageUrlsSet).forEach(async (url) => {
      const urlObj = new URL(url);
      const pathname = urlObj.pathname.split('/').at(-1);
      const assetPath = publicDir + '/images/' + pathname;

      if (fs.existsSync(assetPath)) {
        return;
      }
      console.log({ url, pathname, assetPath });
      return;

      const res = await fetch(url);
      const arrayBuffer = await res.arrayBuffer();
      const buffer = Buffer.from(arrayBuffer);

      fs.mkdirSync(assetPath.split('/').slice(0, -1).join('/'), { recursive: true });
      fs.writeFileSync(assetPath, buffer);
    });
  });
